# 입출력 시스템과 저장장치

### 입출력 시스템

- 초기의 입출력 버스 구조 : Polling방식으로 CPU가 입출력까지 도맡아서 하던 구조, 입출력 명령을 수행하는 동안 CPU가 낭비된다.

- 현대의 입출력 버스 구조 : CPU와 입출력 장치 사이에 입출력 제어기를 둬서 입출력 제어기가 입출력 관련 명령을 수행한다.

- 입출력 버스의 분리 : 입출력 제어기를 도입했지만 속도가 다른 하드웨어들이 같은 버스를 공유하면서 병목 현상이 발생함, 이에 속도가 비슷한 주변장치별로 채널을 분리해 이를 개선했다. 어떤 채널을 탈지는 채널 선택기가 관리한다. 그래픽 카드는 압도적으로 많이 계산량이 필요해 GPU를 자체에 탑재시키고 메인버스에 바로 연결하는 방식을사용한다. 또한 그래픽 카드의 경우 전원 공급을 위해 다른 주변 장치들과는 다른 AGP(Accelerated Graphics Port)로 연결한다.

![](https://yansigit.github.io/posts/%ec%9e%85%ec%b6%9c%eb%a0%a5-%ec%8b%9c%ec%8a%a4%ed%85%9c/Untitled%203.png)

#### 직접 메모리 접근(DMA)

채널 선택기는 여러 채널에서 전송된 데이터 중 어떤 것을 메모리로 보낼 지 선택하지, DMA 제어기를 거쳐 메모리에 올라간다. 반대로 메모리에서 주변장치로 데이터를 전송할 때는 DMA 제어기가 메모리에서 데이터를 가져오면 채널 선택기에서 적당한 채널로 전송한다.

![](https://yansigit.github.io/posts/%ec%9e%85%ec%b6%9c%eb%a0%a5-%ec%8b%9c%ec%8a%a4%ed%85%9c/Untitled%204.png)

입출력 제어기가 사용하는 메모리 공간이 필요한데, 과거에는 해당 메모리를 따로 두었지만 최근에는 메인메모리 내에 입출력 메모리영역을 구분하는 방식을 사용한다.

#### 인터럽트

입출력 작업이 완료되면 입출력 제어기는 각 장치에 있는 IRQ라는 고유의 인터럽트 번호를 포함해 CPU로 인터럽트를 보낸다. 이렇게 외부 장치등으로부터 오는 인터럽트를 외부 인터럽트라고 한다.

이에 반해 프로세스와 관련된 오류를 내부 인터럽트라고 하는데, 예외 상황 인터럽트라고도 부른다.

수동적으로 발생하는 인터럽트와는 다르게 사용자가 직접 발생시키는 인터럽트도 있는데 이를 시그널이라고 한다.

| 종류          | 특징                                | 비고                         |
| ------------- | ----------------------------------- | ---------------------------- |
| 외부 인터럽트 | 입출력 및 하드웨어 관련 인터럽트    | 주변장치 변화, 하드웨어 이상 |
| 내부 인터럽트 | 프로세스의 오류로 발생하는 인터럽트 | 예외 상황 인터럽트           |
| 시그널        | 사용자의 요청으로 발생하는 인터럽트 | 자발적 인터럽트              |

- 인터럽트 벡터 : 어떤 인터럽트가 발생했는지 파악하기 위한 자료구조로 인터럽트 벡터의 값이 1이면 인터럽트가 발생했다는 의미이다.

- 인터럽트 핸들러 : 인터럽트 벡터와 인터럽트 벡터에 연결되어 호출되는 메소드를 뜻한다. 사용자 인터럽트인 시그널의 경우 사용자가 핸들러를 직접 등록할 수도 있다.

![](https://yansigit.github.io/posts/%ec%9e%85%ec%b6%9c%eb%a0%a5-%ec%8b%9c%ec%8a%a4%ed%85%9c/Untitled%205.png)

#### 버퍼링

버퍼는 데이터를 모아서보내는 방식으로 속도가 다른 두 장치의 속도 차이를 완화한다.

![](https://yansigit.github.io/posts/%ec%9e%85%ec%b6%9c%eb%a0%a5-%ec%8b%9c%ec%8a%a4%ed%85%9c/Untitled%206.png)

단일 버퍼의 경우는 버퍼에 데이터를 담는 동작과 데이터를 전송하는 작업을 동시에 하기가 어렵지만 이중 버퍼의 경우는 버퍼별로 역할을 할당할 수 있어서 유용하다.

- 주의점 : 버퍼는 기본적으로 가득찼을 때 전송되도록 구현되어 있는데, 버퍼가 다차기 전에 작업이 끝나면 해당 데이터는 전송되지 않는 현상이 발생한다. 이를 위해 강제로 버퍼를 비우는 flush()를 사용해야 하는 경우가 있다.

### 디스크 장치

#### 하드 디스크

![](https://t1.daumcdn.net/cfile/tistory/998407335C74FC4026)

플래터 : 플래터 표면에는 자성체가 발려져 있어 N극을 띠면 0으로 S극을 띠면 1으로 인식한다. 플래터 수는 보통 2장 이상으로 구성되며 항상 일정한 속도로 회전한다. 플래터의 크기는 3.5인치와 2.5인치로 나뉘는데 3.5인치는 데스크탑 컴퓨터에, 2.5인치는 랩탑에 많이 이용된다.

섹터와 블록 : 물리적인 개념인 섹터는 하드디스크의 가장 작은 저장단위이다. 하나의 섹터에는 한 덩어리의 데이터가 저장된다. 블록은 하드디스크와 컴퓨터 사이에 데이터를 전송하는 논리적인 저장 단위 중 가장 작은 단위이다. 클러스터 라고도 부르며, 메모리에서는 1Byte 마다 주소가 배정되지만 하드디스크에서는 1블록 마다 주소가 배정된다.

트랙과 실린더 : 트랙은 플래터에서 반지름이 동일한 섹터들의 집합을 말한다. 여러개의 플래터에 있는 같은 트랙의 집합을 실린더 라고 부른다.

컴퓨터가 종료되면 헤드는 플래터에 닿지않는 범위로 이동하는 이를 parking이라고 한다.

#### CD

CD도 하드디스크와 마찬가지로 트랙과 센터로 구성되며, 수평적으로 움직이는 헤드가 트랙 사이를 움직이며 데이터를 읽는다. CD의 경우는 자성체를 이용하지 않고 미세한 홈을 이용해 헤드에서 발사된 레이저가 홈에 들어가 정반사 되지 않으면 0으로, 반사되어 돌아오면 1로 인식한다. 640MB를 저장하는 CD, 4.7GB를 저장하는 DVD, 25GB를 저장하는 블루레이 디스크가 있으며 듀얼레이어 DVD는 9.4GB를 저장할 수 있다.

#### 하드 디스크와 CD

하드디스크는 일정한 각속도 방식의 구동 방식을 따르며, CD의 경우는 헤드의 위치에 따라 속도가 바뀌는 일정한 선속도 방식의 구동 방식을 따른다. 이에 하드디스크는 트랙별 섹터의 수가 같지만 CD의 경우는 섹터간의 크기가 동일하며 트랙별 섹터의 수는 다르다. 또한 하드디스크의 경우는 바깥쪽에서부터 데이터를 채우지만 CD는 사용자가 만질 수 있기 떄문에 안쪽에서부터 데이터를 채운다.

- 탐색시간 : 특정 섹터에 저장된 데이터를 읽기 위해 헤더가 이동하는 시간
- 회전 지연 시간 : 이동한 헤더가 원하는 섹터를 만나기까지 걸리는 시간
- 전송시간 : 헤드가 원하는 섹터에 있는 데이터를 읽어 전송하는 시간

데이터 전송시간 = 탐색 시간 + 회전 지연 시간 + 전송시간

### 디스크 장치 관리

#### 파티션

디스크 장치를 논리적으로 분할하는 것을 말한다. 각기 다른 하드디스크 처럼 동작하며 시스템 오류나 바이러스로 인해 문제가 생겼을 때도 해당 파티션내로 국한된다.

#### 포매팅

포매팅은 디스크에 파일 시스템을 탑재하고 디스크 표면을 초기화하여 사용할 수 있는 형태로 만드는것을 말한다. 메모리의 경우 물리 메모리의 주소를 찾기 위해 페이지 테이블을 사용하는 것처럼 디스크의 경우도 파일 테이블이란걸 사용하는데, 포매팅을 할 때 생성된다. 운영체제별로 고유의 파일 테이블이 존재하는데 Window는 FAT, NTFS가 있고 Unix에는 I-node가 있다.

빠른 포매팅은 모든 섹터까지 0으로 만드는 포매팅을 말하며 느린 포매팅은 파일 테이블만 초기화 하는 포매팅을 말한다. 느린 포매팅은 섹터를 0으로 만듬과 동시에 베드섹터를 찾는 일도 같이 수행한다.

#### 조각 모음

파일 입출력을 하다보면 단편화가 일어나는데 이를 해결하기 위해 조각모음을 할 수 있다.

### 네트워크 저장장치

#### DAS(Direct Attached Storage)

HAS(Host Attached Storage)라고도 부르며, 서버와 같은 컴퓨터에 직접 연결된 저장장치를 말한다.

![](https://yansigit.github.io/posts/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-%ec%a0%80%ec%9e%a5%ec%9e%a5%ec%b9%98/Untitled.png)

DAS는 컴퓨터의 메인보드에 있는 입출력 버스와 연결되는데, 이 버스를 사용하는 방식은 IDE, E-IDE를 거쳐 현재는 SATA(Serial Advanced Technology Attachment) 방식을 사용한다.

DAS는 컴퓨터에 직접 연결된 저장장치를 사용하기 때문에 다른 운영체제가 쓰는 파일 시스템을 사용할 수 없다.

#### NAS(Network Attached Storage)

NAS는 기존의 저장장치를 LAN이나 WAN(Wide Area Network)에 붙여서 사용하는 방식이다.

![](https://yansigit.github.io/posts/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-%ec%a0%80%ec%9e%a5%ec%9e%a5%ec%b9%98/Untitled%201.png)

NAS는 전용 운영체제를 가진 독립적인 장치로 새로운 하드디스크를 추가하거나 뺄 수 있다. DAS의 경우 컴퓨터에 붙어 있기 때문에 공유 데이터의 관리가 힘들고 데이터가 여러 컴퓨터에 중복되어 있는 것이 단점이다. NAS는 저장장치를 네트워크 상에 두고 여러 클라이언트가 네트워크를 통해 접근하게 함으로써 공유 데이터의 관리 및 데이터의 중복 회피가 가능하다.

#### SAN(Storage Area Network)

![](https://yansigit.github.io/posts/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-%ec%a0%80%ec%9e%a5%ec%9e%a5%ec%b9%98/Untitled%202.png)

NAS가 저장장치에 네트워크 인터페이스를 부착한 형태라면, SAN은 데이터 서버, 백업 서버, RAID등의 장치를 네트워크로 묶고 데이터 접근을 위한 서버를 두는 형태이다.

### 디스크 스케쥴링

| 알고리즘                          | 설명                                                                               | 비고                                |
| --------------------------------- | ---------------------------------------------------------------------------------- | ----------------------------------- |
| FCFS (First Come First Serve)     | 요청이 들어온 트랙 순서대로 서비스 하는 방식                                       |                                     |
| SSTF(Shortest Seek Time First)    | 헤드의 위치에서 가장 가까운 트랙부터 서비스하는 방식                               | 공평성 위배                         |
| 블록 SSTF                         | 트랙 요청을 일정 단위로 묶어서 SSTF 적용                                           | 성능이 FCFS 만큼 안좋음             |
| SCAN                              | 헤드가 한번 움직이면 움직이는 방향에 있는 요청들만 처리함                          | SSTF와 FCFS의 중간                  |
| C-SCAN                            | 헤드가 한쪽 방향으로 움직일때는 요청 받은 트랙을 서비스하고 돌아 올 때는 이동만 함 | SCAN보다 성능 떨어짐                |
| LOOK                              | SCAN 처럼 수행하지만 헤드가 움직이는 방향에 요청이 없으면 방향을 바꿈              | SCAN보다 성능이 좋음                |
| C-LOOK                            | LOOK에서 서비스할 요청이 없으면 반대로 이동만 함                                   |                                     |
| SLTF(Shortest Latency Time First) |                                                                                    | 드럼을 사용하는 하드디스크에 이용됨 |

### RAID(Redundant Array of Independent Disks)

자동으로 백업을 하고 장애가 발생하면 이를 복구하는 시스템으로, 원본 디스크와 같은 크기의 백업 디스크에 같은 내용을 동시에 저장하고, 하나의 디스크가 고장 났을 때 다른 디스크를 사용하여 데이터를 복구 하는 것이다. mirroring이라고도 한다.

#### RAID 0(striping)

RAID 0은 병렬로 연결된 여러 개의 디스크에 데이터를 동시에 입출력할 수 있도록 구성된다. 이론적으로 일반 시스템보다 입출력 속도가 4배 빠르지만 장애 발생 시 복구하는 기능이 없다.

#### RAID 1(mirroring)

짝수개의 디스크를 사용해 원본 데이터와 백업 데이터를 동시에 저장한다. 장애 발생 시 미러링 된 디스크를 활용하여 데이터를 복구할 수 있다. 백업용 디스크가 필요하다는것과 같은 내용을 두번 저장하기 때문에 속도가 느려질 수 있다는 단점이 있어서 데이터 입출력이 없는 시점에 백업이 이루어지도록 조정하는 것이 좋다.

#### RAID 2

오류를 검출하는 기능이 없는 디스크에 대해 오류 교정 코드(ECC)를 따로 관리하고, 오류가 발생하면 이 코드를 이용하여 디스크를 복구한다.

![](https://blog.kakaocdn.net/dn/dgyRYG/btqANCCQQhY/MzPGfwNv6zks5O20yJus9K/img.png)

- 오류 검출 코드 : 오류가 발생했는지 확인하는 코드로, 패리티 비트가 대표적인 예이다.
- 오류 교정 코드 : 오류가 발생했는지 확인하는 동시에 오류를 교정할 수 있는 코드로, 허밍 코드가 대표적인 예이다.

일반적인 하드디스크에는 오류 검출 코드가 없다. 메모리의 경우 패리티 비트가 있어 오류를 검출할 수 있지만, 오류가 발생했다는 사실만 알고 교정할 수는 없다.

하드디스크의 데이터 저장 단위는 블록이지만, RAID2 에서는 데이터가 비트 단위로 저장된다. 즉, 비트 단위로 디스크에 나누어서 저장한다. 이는 오류 교정을 할 때 비트 단위로 교정하기 위해서 이다. RAID 2는 n개의 디스크에 대해 오류 교정 코드를 저장하기 위해 n-1개의 추가 디스크를 필요로 하므로 RAID1 보다는 요구하는 공간이 작지만 계산에 많은 시간이 소모되므로 잘 사용하지 않는다.

#### RAID 3

RAID 3와 RAID 4에서는 오류 검출 코드인 패리티 비트를 사용하여 데이터를 복구한다. 원래는 패리티 비트로 복구할 수 없지만 RAID의 경우는 가능하다.

![](https://mblogthumb-phinf.pstatic.net/20130708_18/capemay_1373262434639V23Nr_GIF/raid-level-3.gif?type=w2)

패리티 비트에는 짝수 패리티비트와 홀수 패리티 비트가 있는데 각 디스크의 비트를 더해서 짝수 혹은 홀수를 만들고 이를 통해 오류가 발생했을때 검출하고 복구하는 것이다. 일반적으로 오류 검출 코드의 크기가 오류 정정 코드보다 작기 때문에 RAID 3 에서 추가되는 디스크의 양은 4개당 디스크 1개 정도이다.
필요한 디스크는 적지만 N-way 패리티 비트를 구성하는 데 필요한 계산량이 많다는 것이 단점이다.

#### RAID 4

RAID 4 는 RAID 3과 같은 방식이지만 처리하는 데이터가 블록 단위이다. RAID 3 는 비트 단위로 나누어 저장하는 방식으로 패리티 비트를 구성하는데, 이 때문에 모든 디스크가 동시에 동작해야 하는 단점이 있다.

RAID 4 에서는 데이터를 하나의 디스크에 블록 단위로 저장하고 패리티 비트를 블록과 연결하여 구성한다. 따라서 해당 디스크만 동작하면 된다. RAID 4 또한 계산량이 많다는 단점이 있다.

#### RAID 5

RAID 4를 사용하지 않는 이유는 병목현상 때문이다. RAID 4 에서는 모든 패리티 비트가 하나의 디스크에 저장되기 때문에 입출력이 일어날 때마다 패리티 비트 디스크에 데이터가 저장되어 병목 현상이 발생한다. 또한 패리비 비트 디스크와 원본 디스크에 동시에 장애가 발생할 경우 복구가 불가능한 단점이 있다.

![](https://t1.daumcdn.net/cfile/tistory/22381E3F590036D340)

RAID 5는 패리티 비트를 여러디스크에 분산하여 이러한 병목현상을 해결하고 패리티 비트의 디스크가 고장나면 복구가 어렵다는 점도 완화했다.

#### RAID 6

RAID 5의 경우 한 디스크에 장애가 발생했을 때는 복구가 가능하지만 디스크 2개에 동시에 장애가 발생했을 때는 복구가 불가능하다. 이를 해결하기 위해 RAID 6는 패리티 비트를 2개로 구성하여 분산한다. RAID 6의 단점은 패리티 비트를 2개씩 운영하기 때문에 RAID 5 보다 계산량이 많다는 점과 디스크도 추가적으로 더 필요하다는 것이다.

![](https://t1.daumcdn.net/cfile/tistory/2654D23F590051C307)

#### RAID 10

빠른 입출력이 장점인 RAID 0과 복구 기능을 가진 RAID 1을 결합한 방식이다.

![](https://www.2cpu.co.kr/data/froala/4raid/191019/191019_4raid_79ffa7f7b29a14341a9304eeda5a75006ed752ce.jpeg)
![](https://www.tecmint.com/wp-content/uploads/2014/11/Setup-Raid-10-in-Linux.jpeg)

RAID 10과 RAID 0+1 둘 다 병렬로 데이터를 처리하여 입출력 속도를 높일 수 있으며 장애 발생 시 미러링된 디스크로 복구가 가능하다. 차이점은 RAID 0+1의 경우 장애가 발생했을 때 복구하기 위해 모든 디스크를 중단해야 하지만 RAID 10은 일부 디스크만 중단하여 복구할 수 있다는 것이다. 복구와 효율성 문제로 RAID 0+1보다는 RAID 10을 더 많이 사용한다.

#### RAID 50과 RAID 60

RAID 50과 60은 RAID 10과 마찬가지로 같은 RAID를 0으로 묶어 성능을 높이는 방식이다. RAID 50에서는 RAID 5를 묶은 두 쌍을 다시 RAID 0으로 묶어 사용하고, RAID 60 에서는 RAID 6으로 묶은 두 쌍을 다시 RAID 0 으로 묶어 사용한다.

![](https://i.ytimg.com/vi/sz4x0YSimbs/hqdefault.jpg)
![](https://i.ytimg.com/vi/sUEMlrlFgEY/hqdefault.jpg)
