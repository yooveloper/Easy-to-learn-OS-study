# CHAPTER 11 파일 시스템

# 파일과 파일 시스템

## 파일 시스템의 개요

- 보안상의 이유로 사용자 대신 파일 관리자가 저장장치 관리를 하는 것이다. 파일 관리자는 파일을 보관하고 관리한다.
- 파일 관리자는 파일 테이블을 사용하여 파일의 생성, 수정, 삭제 등을 수행한다.
- 파일 관리자는 사용자가 파일을 사용하고자 할 때 읽기, 쓰기, 실행과 같은 다양한 접근 방법을 제공한다.
- 사용자가 특정 파일에 접근하기 위해서는 파일 관리자로부터 파일 디스크립터-파일 접근 권한- 을 획득해야 한다.

### 파일 시스템의 기능

| 기능 | 설명 |
| --- | --- |
| 파일 구성 | 사용자의 요구에 따라 파일과 디렉터리를 만든다. |
| 파일 관리 | 파일 생성, 수정, 삭제 등의 관리를 하고, 수시로 조각 모음을 하여 사용자가 파일에 빨리 접근할 수 있도록 한다. |
| 접근 권한 관리 | 다른 사용자로부터 파일을 보호하기 위해 접근 권한을 관리한다. |
| 접근 방법 제공 | 파일을 읽고 쓰고 실행할 수 있도록 사용자에게 접근 방법을 제공한다. |
| 무결성 보장 | 파일의 내용이 손상되지 않도록 무결성을 보장한다. |
| 백업과 복구 | 사고로부터 파일을 보호하기 위해 백업과 복구 작업을 한다. |
| 암호화 | 파일을 암호화하여 악의적인 접근으로부터 파일을 보호한다. |

### 블록과 파일 테이블

- 블록: 저장장치에서 사용하는 가장 작은 단위로, 한 블록에 주소 하나가 할당된다.
- 섹터: 하드디스크의 가장 작은 저장 단위
- 바이트: 메모리의 저장 단위
- 하드디스크의 크기가 메인 메모리의 크기의 수백 배 이상 크기 때문에 섹터마다 주소를 부여하면 너무 많은 양의 주소가 필요하다. 이 때문에 파일 관리자는 여러 섹터를 묶어 하나의 블록으로 만들고, 블록 하나에 주소 하나를 배정한다.
- 포맷을 하면 각 블록에 번호가 매겨지고 파일 테이블에는 파일이 어떤 블록에 있는지 명시된다.

<aside>
💡 **블록 크기에 따른 장단점**
블록 크기를 작게 설정하면 내부 단편화 현상이 줄어들어 저장장치를 효율적으로 쓸 수 있지만, 파일이 여러 블록으로 나뉘어 파일 입출력 속도가 느려진다. 따라서 큰 파일을 많이 사용할 때는 블록 크기를 크게 잡는 것이 좋다.

</aside>

## 파일 분류와 확장자

### 파일

- 논리적인 데이터의 집합으로 하드디스크나 CD 같은 제2 저장장치에 저장된다.
- 모든 파일은 0과 1의 비트 패턴으로 이루어진다.
- 실행 파일과 데이터 파일로 나뉜다.

### 실행 파일

- 운영체제가 메모리로 가져와 CPU를 이용하여 작업을 하는 파일
- 사용자의 요청으로 프로세스가 되는 파일

### 데이터 파일

- 실행 파일이 작업하는 데 필요한 데이터를 모아놓은 파일
- 스스로 프로세스가 될 수 없다.
- 운영체제가 전송하거나 보관만 하고 특별하게 다루지는 않는다.
- Ex:) 사진 파일, 음악 파일, 문서 파일 등

## 파일 속성

### 파일 헤더

- 파일 테이블에서 관리하며 일반적인 내용이 담겨 있다.
- 파일이 저장장치의 몇 번째 블록에 있는지에 대한 정보도 가지고 있다.

| 속성 | 특징 | 속성 | 특징 |
| --- | --- | --- | --- |
| name | 파일의 이름 | location | 파일의 위치 |
| type | 파일의 종류 | accessibility | 파일의 접근 권한 |
| size | 파일의 크기 | owner | 파일의 소유자 |
| time | 파일의 접근 시간 |  |  |

### 고유 헤더

- 데이터 파일에 달려 있는 헤더로, 각 응용 프로그램이 필요로 하는 내용이다.
- 파일의 버전 번호, 크기, 특수 정보 등이 담겨 있다.

<aside>
💡 **파일 복구**
빠른 포맷을 한다면 파일 테이블에 있던 파일 헤더가 사라진다. 하지만 빠른 포맷이나 휴지통에 파일을 버리는 행위는 파일 데이터만 지우고 실제 데이터를 지우지는 않는다. 때문에 파일 테이블에서만 사라질 뿐 실제 데이터는 지워지지 않는다. 따라서 데이터 파일의 고유 헤더는 저장장치에 남아 있다.
파일 복구 프로그램은 모든 블록을 찾아다니면서 고유 헤더에 있는 정보를 이용하여 파일을 원래 상태로 복원한다. 잘 알려지지 않은 헤더는 복구가 안 되지만 JPG, MP3 같은 파일은 헤더에 어떤 정보를 넣을지 전 세계적으로 규격을 정했기 때문에 헤더만 찾는다면 복구할 수 있다.

</aside>

## 파일 작업의 유형

### 파일 자체를 변경하는 작업

사용자 입장에서 수행한다.

| 작업 | 설명 |
| --- | --- |
| open | 파일을 연다. 파일을 더블클릭하면 연결 프로그램이 실행되어 파일이 열린다. 또는 연결 프로그램을 실행한 후 데이터 파일을 가져온다. |
| close | 파일을 다 사용하고 나면 닫는다. 응용 프로그램을 종료해도 자동으로 파일이 닫힌다. |
| create | 새로운 파일을 생성한다. 워드프로세서에서 [새 문서] 메뉴를 클릭하여 작업한 후 파일의 이름을 지정하여 저장하면 파일이 생성된다. 그림판에서 새로운 그림을 그리거나 스캐너로 문서를 스캔하는 경우에도 새로운 파일이 생성된다. |
| remove | 파일을 다른 디렉터리로 이동하거나 휴지통으로 이동하면 파일이 삭제된다. |
| copy | 똑같은 파일을 하나 더 만드는 것이다. |
| rename | 파일 이름을 바꾸는 것이다. |
| list | 디렉터리에 있는 파일의 이름을 보여주는 것이다. 파일의 이름뿐 아니라 크기, 만든 날짜 등도 같이 나열된다. |
| search | 여러 디렉터리에서 파일을 찾을 때 사용한다. 이름순, 크기순, 만든 날짜순 등 다양한 기준으로 검색이 가능하다. 모든 문자를 대체한다는 의미를 가진 ‘*’, 모르는 글자의 수를 지정하는 데 사용되는 ‘?’와 같은 특수 기호를 사용하여 검색할 수도 있다.  |

### 파일 내용을 변경하는 작업

프로세스 입장에서 수행하는 것으로, 주로 함수 형태이다.

| 작업 | 설명 |
| --- | --- |
| open() | 파일을 연다. |
| create() | 새로운 파일을 생성한다. |
| close() | 파일을 닫는다. |
| read() | 파일 내용을 읽는다. |
| write() | 파일에 새로운 내용을 쓴다. |
| update() | 파일 내용 중 일부를 변경한다. |
| insert() | 파일에 새로운 내용을 추가한다. |
| delete() | 파일 내용 중 일부를 지운다. |

## 파일 구조

### 순차 파일 구조

- 파일 내용이 하나의 긴 줄로 늘어선 형태이다.
- 초기의 컴퓨터가 사용한 형태이다.

**장점**

- 모든 데이터가 순서대로 기록되기 때문에 저장 공간에 낭비되는 부분이 없다.
- 구조가 단순하여 테이프는 물론 플로피디스크나 메모리를 이용한 저장장치에도 적용할 수 있다.
- 순서대로 데이터를 읽거나 저장할 때 매우 빠르게 처리된다.

**단점**

- 파일에 새로운 데이터를 삽입하거나 삭제할 때 시간이 많이 걸린다. 중간에 데이터를 삽입하려면 그 뒤에 있는 데이터를 뒤로 밀어 빈 공간을 만들어야 하고, 중간의 데이터를 삭제했을 때는 남은 빈 공간을 메우기 위해 그 뒤에 있는 데이터를 앞으로 당겨야 한다. 따라서 순차 파일 구조는 **데이터의 변경이 잦은 경우에 적당하지 않다.**
- 특정 데이터로 이동할 때 직접 접근이 어렵기 때문에 앞에서부터 순서대로 움직여야 한다. 따라서 순차 파일 구조는 데이터 검색에 적당하지 않다.

### 인덱스 파일 구조

- 순차 파일 구조에서는 특정 데이터에 접근하기 위해 앞에서부터 순차적으로 이동해야 한다. 인덱스 파일 구조는 이러한 단점을 해결한 파일 구조이다.
- 순차 파일 구조에 인덱스 테이블을 추가하여 순차 접근과 직접 접근이 가능하다.
- 현대의 파일 시스템은 인덱스 파일 구조로, 파일을 저장할 때는 순차 파일 구조로 저장하고 파일에 접근할 때는 인덱스 테이블을 보고 원하는 파일에 직접 접근한다.
- 테이블을 여러 개 만들면 다양한 접근이 가능하다.
- 데이터베이스같이 데이터의 빠른 접근이 필요한 시스템에 사용된다.
- 데이터베이스는 일반적으로 B 트리를 이용하여 인덱스를 구성한다.

### 직접 파일 구조

- 저장하려는 데이터의 특정 값에 어떤 관계를 정의하여 물리적인 주소로 바로 변환하는 파일 구조이다.
- 특정 함수를 이용하여 직접 접근이 가능한 파일 구조이다.
- 해시 함수를 사용하여 주소를 변환하기 때문에 데이터 접근이 매우 빠르다.
- 전체 데이터가 고르게 저장될 수 있는 해시 함수를 찾는 것이 매우 중요하다.
- 해시 함수를 잘 찾았다고 하더라도 저장 공간이 낭비되는 문제가 있다.

# 디렉터리의 구조

## 디렉터리의 개념

- 관련 있는 파일을 하나로 모아놓은 곳
- 1개 이상의 자식 디렉터리를 가질 수 있고, 1개 이상의 파일을 가질 수 있다. 즉, 하나의 디렉터리에는 여러 개의 파일과 자식 디렉터리가 존재할 수 있다.
- 디렉터리는 여러 층으로 구성할 수 있다.

## 디렉터리 파일

- 디렉터리도 파일의 일종이다.
- 일반 파일에 데이터가 담겨 있듯이, 디렉터리에는 파일 정보가 담겨 있다.
- 디렉터리도 일반 파일과 마찬가지로 헤더를 가진다. 디렉터리 헤더에는 디렉터리의 이름, 만든 시간, 접근 권한 등의 정보가 기록되어 있다.

| 마침표(.) 파일 | 자기 자신의 디렉터리 |
| --- | --- |
| 2개 마침표(..) 파일 | 상위 디렉터리 |

## 경로

- 파일이 전체 디렉터리 중 어디에 있는지를 나타내는 정보
- 한 디렉터리에는 같은 이름을 가진 파일이 존재할 수 없지만, 서로 다른 디렉터리에는 같은 이름의 파일이 존재할 수 있다.
- 절대 경로
    - 루트 디렉터리에서 시작하는 절대적인 위치
    - Ex:) /program/data/exm.c
- 상대 경로
    - 현재 있는 위치를 기준으로 파일의 위치 표시
    - Ex:) data/exam.c, ../user/exm.c
- cd 명령
    - 디렉터리를 이동할 때 사용하는 명령
    - 절대 경로와 상대 경로 모두 사용 가능하다.
    - 현재 위치보다 아래에 있는 데이터에 접근 → 상대 경로, Ex:) cd data
    - 다른 디렉터리로 이동 → 절대 경로, Ex:) cd /program/data

## 디렉터리 구조

### 1단계 구조

- 초기 파일 시스템의 디렉터리 구조이다.
- 루트 디렉터리에 새로운 디렉터리를 만들 수 있지만 디렉터리 안에 자식 디렉터리를 만들 수는 없다. 즉, 최대 1단계만 구현 가능하다.

### 다단계 디렉터리 구조

- 루트 디렉터리를 시작점으로 여러 단계의 디렉터리가 가지처럼 뻗어 있다.
- 트리 디렉터리 구조라고도 한다.
- 단계 확장에 제약이 없고 디렉터리에 파일과 디렉터리를 둘 다 저장할 수 있다.

### 순환이 있는 다단계 디렉터리 구조

- 오늘날의 디렉터리 구조로, 순환이 있다.
- 디렉터리와 디렉터리를 연결하는 링크가 있다. 윈도우의 바로가기가 그 예이다.
- 그래프 구조이다.

## 마운트

논리적인 디스크 분할인 파티션을 통해, 하나 이상의 디스크를 나누어 사용할 수 있었다. 그런데 이러한 파티션이 사용자에게 노출되면 사용하기 불편하다. 윈도우에서 각 파티션이 따로 보이는 이유는 파티션마다 `파일 테이블`이 따로 존재하기 때문이다.

초기 윈도우에서는 파일 시스템의 최대 디스크 크기가 제한되었기 때문에 파티션을 나누어 파티션마다 서로 다른 `파일 테이블`을 사용해야 했다.

유닉스의 경우 서버용으로 만들어진 운영체제이기 때문에 `파일 테이블` 크기에 제한이 없고, 하나의 파일 테이블로 여러 개의 디스크 혹은 파티션을 통합하여 관리할 수 있다. 이렇게 **여러 개의 파티션을 통합하는 명령어를 마운트라고 한다.**

마운트를 사용하면 디렉터리를 이동할 때마다 다른 파티션으로 넘어가지만, 사용자에게는 한 파티션으로 보이기 때문에, 사용자는 몇 개의 파티션이 합쳐져 있는지 모른다.

마운트를 사용하면 파티션이 몇 개라도 하나로 통합할 수 있다.

# 디스크 파일 할당

참고: [파일 할당](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-18.-%ED%8C%8C%EC%9D%BC-%ED%95%A0%EB%8B%B9)

## 연속 할당과 불연속 할당

- 파일 시스템은 메인 메모리 시스템과 유사해서, 전체 디스크 공간을 같은 크기로 나누고 각 공간에 주소를 붙여서 관리한다.
- 같은 크기로 나뉜 공간 하나를 블록이라고 한다.
- 파일 시스템은 파일의 이름과 해당 파일이 시작하는 블록 주소를 가진 `파일 테이블`을 관리한다.
- 만약, 응용 프로그램이 어떤 파일에서 데이터를 읽고자 하면, 파일 관리자는 `파일 테이블`에서 해당 파일의 블록 주소를 찾아 그 위치에서 데이터를 읽어온다.
- `파일 테이블`은 파티션당 하나씩 존재하며, 각 파티션의 맨 앞부분에 위치한다.
- 일반적으로 하나의 파일은 여러 개의 블록을 사용하는데, 이 블록들의 연결 방식에 따라 연속 할당과 불연속 할당으로 구분된다.

### 연속 할당

![https://user-images.githubusercontent.com/34755287/57186867-72ac2900-6f21-11e9-9542-e68d1eef7e27.png](https://user-images.githubusercontent.com/34755287/57186867-72ac2900-6f21-11e9-9542-e68d1eef7e27.png)

- 파일을 구성하는 데이터를 디스크상에 연속적으로 배열하는 간단한 방식
- 파일의 시작 블록만 알면 전체 파일을 찾을 수 있다.
- 파일을 저장하거나 삭제하다 보면 빈 공간이 생긴다. 디스크에 남은 공간 중 파일의 크기에 맞는 연속된 공간이 없을 때는 연속 할당이 불가능하다.
→ 실제로는 사용되지 않는다.

### 불연속 할당

- 비어 있는 블록에 데이터를 분산하여 저장하고 이에 관한 정보를 파일 시스템이 관리하는 방식
- 구현 방식으로 연결 리스트를 활용한 `연결 할당`, 인덱스를 활용한 `인덱스 할당`이 있다.

### 연결 할당

![https://user-images.githubusercontent.com/34755287/57186868-72ac2900-6f21-11e9-94a6-40054c58852b.png](https://user-images.githubusercontent.com/34755287/57186868-72ac2900-6f21-11e9-94a6-40054c58852b.png)

- 파일에 속한 데이터를 연결 리스트로 관리하는 방식
- 파일 테이블에는 시작 블록에 대한 정보만 저장하고, 나머지 데이터는 시작 블록부터 연결하여 저장한다.
- 파일의 맨 끝에 해당하는 블록에는 링크 대신 null을 삽입한다.
- 체인으로 연결한 것처럼 보여서 체인 할당이라고도 한다.

<aside>
💡 **연결 할당 방식의 문제점**
1. 직접 접근이 불가능하다. 파일의 블록들은 모두 흩어져 있기 때문에 시작 블록 번호를 가지고 원하는 위치의 블록에 바로 접근할 수 없다.
2. 포인터를 저장하는 공간이 필요하다.
3. 중간 블록의 포인터가 끊어지면 그 이후의 모든 블록에 접근하지 못한다.
4. 블록이 모두 흩어져 있으므로 디스크 헤더의 움직임이 많이 발생한다.

</aside>

### FAT(File Allocation Table)

![https://user-images.githubusercontent.com/34755287/57186869-72ac2900-6f21-11e9-98db-e780d2db15ea.png](https://user-images.githubusercontent.com/34755287/57186869-72ac2900-6f21-11e9-98db-e780d2db15ea.png)

- 연결 할당 방식의 문제점을 개선한, 새로운 연결 할당 방식이다.
- 다음 블록을 가리키는 포인터들만 모아서 하나의 테이블(이름: FAT)로 만든다.
- FAT의 인덱스는 전체 디스크의 블록 번호이고, 각 인덱스마다 다음 블록 번호를 저장하고 있다.
- FAT를 한 번만 읽으면 직접 접근이 가능하다.
- 중간 블록의 포인터가 끊어져도 FAT에 문제가 없다면 FAT의 정보를 통해 그 다음 블록을 읽을 수 있다.
- 일반적으로 메모리 캐싱을 사용하기 때문에 블록 위치를 찾는 것은 빠르지만, 블록이 흩어져 있기 때문에, 실제 디스크 헤더가 움직이는 것은 여전히 느리다.
- 매우 중요한 정보이므로, 손실 시 복구를 위해 이중 저장한다.
- `각 인덱스 크기 == 전체 블록의 개수를 저장할 만큼의 크기`이며, 현재는 32bit를 많이 사용한다.

### 인덱스 할당

![https://user-images.githubusercontent.com/34755287/57186870-72ac2900-6f21-11e9-8b3b-531b44ea89ce.png](https://user-images.githubusercontent.com/34755287/57186870-72ac2900-6f21-11e9-8b3b-531b44ea89ce.png)

- 테이블의 블록 포인터가 데이터의 인덱스를 담고 있는 인덱스 블록을 연결한다.
- 인덱스 블록은 실제 데이터의 위치에 관한 정보를 순서대로 보관하고 있다.
- 테이블이 꽉 차서 더 이상 데이터를 연결할 수 없을 때는 인덱스 블록을 연결하는 간접 인덱스 블록을 통해 테이블을 무한히 확장할 수 있다.
- 대표적인 예로 유닉스의 I-node가 있다.

### I-node 파일 시스템

![https://velog.velcdn.com/images%2Fredgem92%2Fpost%2Fd9bcaff6-2ffc-4404-a40e-a892f490b769%2Fimage.png](https://velog.velcdn.com/images%2Fredgem92%2Fpost%2Fd9bcaff6-2ffc-4404-a40e-a892f490b769%2Fimage.png)

- `인덱스 할당 방식`을 사용하는 파일 시스템
- **파일 크기가 작은 경우 블록을 직접 연결하여 빠르게 접근하고, 파일 크기가 큰 경우 인덱스 블록과 이를 연결하는 간접 포인터를 이용하여 확장한다.**

| 파일 제어 블록 | Mode, Owner Info, Size, Timestamps 등 각종 속성을 나타낸다. 파일에 대한 모든 권한의 정보를 포함하기 때문에 슈퍼블록이라고도 한다. |
| --- | --- |
| 블록 포인터
(Direct Blocks) | 데이터가 있는 블록의 위치를 직접 연결하는 포인터이다. |
| 간접 포인터
(Indirect Pointer) | 크기가 큰 파일의 경우, 블록 포인터가 다 차면 인덱스 블록을 생성한 후 간접 포인터를 생성하여 인덱스 블록을 연결한다. |
| 이중/삼중 간접 포인터(Double Indirect, 
Triple Indirect) | 파일 크기가 커서 인덱스 블록 하나로 다 연결할 수 없는 경우 이중 간접 포인터를 사용하고, 이보다 더 필요한 경우에는 삼중 간접 포인터를 사용하여 연결한다.
인덱스 블록 하나는 256개의 블록 지정, 이중 간접 포인터는 256^2개의 블록 지정, 삼중 간접 포인터는 256^3개의 블록을 지정할 수 있다. |

## 디스크의 빈 공간 관리

- **디스크 블록 하나의 크기를 크게 잡으면**, 적은 주소로 많은 양의 데이터를 관리할 수 있지만 낭비되는 공간이 생긴다. 이러한 낭비되는 공간을 `**내부 단편화**`라고 한다.
- 디스크 블록 하나의 크기를 작게 잡으면, 많은 양의 블록 포인터가 필요하다.
- 디스크에 파일을 저장할 때마다 모든 테이블을 뒤져서 빈 공간을 찾는 것은 비효율적이다. 디스크의 내부 단편화를 줄이고, 빈 공간을 효율적으로 활용하기 위해 파일 시스템은 **빈 블록의 정보만 모아 놓은**, `**빈 공간 리스트**`를 유지한다.
- 디스크에서 파일 삭제를 할 때는, 사용했던 블록의 내용을 일일이 지우는 대신, 파일 테이블의 헤더를 삭제하고 사용했던 블록을 빈 공간 리스트에 등록하고, 이를 파일이 삭제된 것으로 간주한다.
- 블록의 내용을 지우지 않고 빈 공간 리스트에 삽입하는 것은, 해당 블록에 새로운 데이터를 덮어쓰지 않는 한 원래 데이터를 복구할 수 있는 여지를 남기는 것이다. 만약 새로운 데이터를 디스크에 넣는다면, 빈 블록 리스트의 가장 앞에 있는 블록에 할당된다.
→ 이러한 특징 때문에 디스크 복구나 휴지통에서 삭제한 파일을 되살리는 것이 가능하다.

# 질문 목록

- I-Node가 무엇인가요?
- 디스크 내부 단편화의 원인이 무엇인가요?
- 디스크의 빈 공간 리스트가 무엇인가요?